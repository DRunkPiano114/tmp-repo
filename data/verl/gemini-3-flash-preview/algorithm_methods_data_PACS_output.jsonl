{"function_name": "compute_reward", "overview": "Computes \"reward\" for policy improvement, measuring log probability change of current policy relative to reference policy.", "function_signature": "def compute_reward(\nold_log_prob,\nlog_prob,\nresponse_mask,\nbeta=1.0,\nreward_method=\"1\",\n):", "input_parameters": "- `old_log_prob`: Reference policy token-level log probabilities, shape `[batch_size, response_length]`\n- `log_prob`: Current policy token-level log probabilities, shape `[batch_size, response_length]`\n- `response_mask`: Response portion mask, shape `[batch_size, response_length]`\n- `beta`: Reward scaling factor, controls aggressiveness of policy updates (default 1.0)\n- `reward_method`: Reward computation method, '1' or '2'", "detailed_description": "Function computes reward values in reinforcement learning based on specified method.\nMethod 1 computes sum of new-old log probability differences, measuring policy improvement magnitude.\nMethod 2 computes normalized sum of current log probabilities.\nIf an invalid method number is specified, function raises an exception.", "output": "- `reward`: Policy improvement reward, shape `[batch_size, 1]`", "func_implementation": "", "test_code_path": "code/test_code/test_compute_reward.py", "implementation_location": "code/src/pacs/pacs_core_algos.py:line 7-21", "prompt": [{"role": "system", "content": "You are a Python programmer developing with the verl framework. verl (Volcano Engine Reinforcement Learning) is a flexible, efficient and production-ready RL training library for large language models (LLMs). It supports various RL algorithms like PPO and GRPO, integrates with mainstream frameworks including FSDP, Megatron-LM, vLLM, and SGLang, features state-of-the-art throughput performance and flexible device mapping capabilities, and scales to hundreds of GPUs and hundreds of billion parameter models."}, {"role": "user", "content": "Please implement a function named `compute_reward`.\n\n**Function Overview:**\nComputes \"reward\" for policy improvement, measuring log probability change of current policy relative to reference policy.\n\n**Function Signature:**\n```python\ndef compute_reward(\nold_log_prob,\nlog_prob,\nresponse_mask,\nbeta=1.0,\nreward_method=\"1\",\n):\n```\n\n**Input Parameters:**\n- `old_log_prob`: Reference policy token-level log probabilities, shape `[batch_size, response_length]`\n- `log_prob`: Current policy token-level log probabilities, shape `[batch_size, response_length]`\n- `response_mask`: Response portion mask, shape `[batch_size, response_length]`\n- `beta`: Reward scaling factor, controls aggressiveness of policy updates (default 1.0)\n- `reward_method`: Reward computation method, '1' or '2'\n\n**Detailed Description:**\nFunction computes reward values in reinforcement learning based on specified method.\nMethod 1 computes sum of new-old log probability differences, measuring policy improvement magnitude.\nMethod 2 computes normalized sum of current log probabilities.\nIf an invalid method number is specified, function raises an exception.\n\n**Expected Output:**\n- `reward`: Policy improvement reward, shape `[batch_size, 1]`\n\nPlease implement this function based on the above information, ensuring that:\n1. The function signature matches the one provided above\n2. The implementation follows the logic described in the detailed description\n3. All input parameters are properly handled\n4. The return value matches the expected output format\n5. The code style is clear with necessary comments\n\nPlease provide the Python function implementation code directly."}], "completions": ["```python\nimport torch\n\ndef compute_reward(\n    old_log_prob,\n    log_prob,\n    response_mask,\n    beta=1.0,\n    reward_method=\"1\",\n):\n    \"\"\"\n    Computes \"reward\" for policy improvement, measuring log probability change \n    of current policy relative to reference policy.\n\n    Args:\n        old_log_prob: Reference policy token-level log probabilities, shape [batch_size, response_length]\n        log_prob: Current policy token-level log probabilities, shape [batch_size, response_length]\n        response_mask: Response portion mask, shape [batch_size, response_length]\n        beta: Reward scaling factor, controls aggressiveness of policy updates (default 1.0)\n        reward_method: Reward computation method, '1' or '2'\n\n    Returns:\n        reward: Policy improvement reward, shape [batch_size, 1]\n    \"\"\"\n    \n    # Ensure the mask is used to zero out log probabilities outside the response tokens\n    # This ensures we only sum values relevant to the generated response\n    masked_old_log_prob = old_log_prob * response_mask\n    masked_log_prob = log_prob * response_mask\n\n    if reward_method == \"1\":\n        # Method 1: Computes sum of new-old log probability differences.\n        # This measures the magnitude of policy improvement relative to the reference.\n        # Formula: beta * sum(log_prob - old_log_prob)\n        kl_divergence_estimate = masked_log_prob - masked_old_log_prob\n        reward = beta * kl_divergence_estimate.sum(dim=-1, keepdim=True)\n        \n    elif reward_method == \"2\":\n        # Method 2: Computes normalized sum of current log probabilities.\n        # This focuses on the absolute likelihood of the sequence under the current policy.\n        # Formula: beta * sum(log_prob) / sum(mask)\n        token_counts = response_mask.sum(dim=-1, keepdim=True)\n        # Avoid division by zero if a mask is empty\n        token_counts = torch.clamp(token_counts, min=1.0)\n        reward = beta * masked_log_prob.sum(dim=-1, keepdim=True) / token_counts\n        \n    else:\n        raise ValueError(f\"Invalid reward_method: {reward_method}. Expected '1' or '2'.\")\n\n    return reward\n```"], "usage": {"prompt_tokens": 478, "completion_tokens": 569, "total_tokens": 1047, "per_completion": [{"prompt_tokens": 478, "completion_tokens": 569, "total_tokens": 1047}]}}
{"function_name": "compute_weight", "overview": "Computes sample weights to handle class imbalance problem (uneven positive/negative sample ratio).", "function_signature": "def compute_weight(score, rollout_n, mode=\"question\"):", "input_parameters": "- `score`: Verifiable rewards (labels), shape `[batch_size, 1]`\n- `rollout_n`: Number of responses generated per prompt\n- `mode`: Weight computation mode, 'question'/'only_positive'/'only_negative'", "detailed_description": "Function assigns training weights to samples based on different modes. In \"question\" mode, function groups samples by rollout_n size, using class-balanced weights for groups with label imbalance to make positive and negative samples contribute equally to training. In \"only_positive\" mode, only positive samples (label 1) are assigned weight 1.0, negative samples get weight 0. In \"only_negative\" mode, the opposite applies: only negative samples (label 0) are assigned weight 1.0. If an invalid mode is specified, function raises an exception.", "output": "- `weight`: Sample weights, shape `[batch_size, 1]`", "func_implementation": "", "test_code_path": "code/test_code/test_compute_weight.py", "implementation_location": "code/src/pacs/pacs_core_algos.py:line 59-86", "prompt": [{"role": "system", "content": "You are a Python programmer developing with the verl framework. verl (Volcano Engine Reinforcement Learning) is a flexible, efficient and production-ready RL training library for large language models (LLMs). It supports various RL algorithms like PPO and GRPO, integrates with mainstream frameworks including FSDP, Megatron-LM, vLLM, and SGLang, features state-of-the-art throughput performance and flexible device mapping capabilities, and scales to hundreds of GPUs and hundreds of billion parameter models."}, {"role": "user", "content": "Please implement a function named `compute_weight`.\n\n**Function Overview:**\nComputes sample weights to handle class imbalance problem (uneven positive/negative sample ratio).\n\n**Function Signature:**\n```python\ndef compute_weight(score, rollout_n, mode=\"question\"):\n```\n\n**Input Parameters:**\n- `score`: Verifiable rewards (labels), shape `[batch_size, 1]`\n- `rollout_n`: Number of responses generated per prompt\n- `mode`: Weight computation mode, 'question'/'only_positive'/'only_negative'\n\n**Detailed Description:**\nFunction assigns training weights to samples based on different modes. In \"question\" mode, function groups samples by rollout_n size, using class-balanced weights for groups with label imbalance to make positive and negative samples contribute equally to training. In \"only_positive\" mode, only positive samples (label 1) are assigned weight 1.0, negative samples get weight 0. In \"only_negative\" mode, the opposite applies: only negative samples (label 0) are assigned weight 1.0. If an invalid mode is specified, function raises an exception.\n\n**Expected Output:**\n- `weight`: Sample weights, shape `[batch_size, 1]`\n\nPlease implement this function based on the above information, ensuring that:\n1. The function signature matches the one provided above\n2. The implementation follows the logic described in the detailed description\n3. All input parameters are properly handled\n4. The return value matches the expected output format\n5. The code style is clear with necessary comments\n\nPlease provide the Python function implementation code directly."}], "completions": ["```python\nimport torch\n\ndef compute_weight(score, rollout_n, mode=\"question\"):\n    \"\"\"\n    Computes sample weights to handle class imbalance problem (uneven positive/negative sample ratio).\n\n    Args:\n        score: Verifiable rewards (labels), shape [batch_size, 1]\n        rollout_n: Number of responses generated per prompt\n        mode: Weight computation mode, 'question'/'only_positive'/'only_negative'\n\n    Returns:\n        weight: Sample weights, shape [batch_size, 1]\n    \"\"\"\n    # Ensure score is a torch tensor\n    if not isinstance(score, torch.Tensor):\n        score = torch.tensor(score)\n\n    batch_size = score.shape[0]\n    weight = torch.zeros_like(score, dtype=torch.float32)\n\n    if mode == \"question\":\n        # Process in groups of rollout_n (samples belonging to the same prompt)\n        for i in range(0, batch_size, rollout_n):\n            group_score = score[i : i + rollout_n]\n            \n            # Count positive (1) and negative (0) samples in the group\n            num_pos = torch.sum(group_score == 1).item()\n            num_neg = torch.sum(group_score == 0).item()\n            \n            # If the group contains both positive and negative samples, balance them\n            if num_pos > 0 and num_neg > 0:\n                # Calculate weights such that sum(pos_weights) == sum(neg_weights)\n                # Here we normalize so each class contributes 0.5 to the group's total weight\n                pos_weight = 1.0 / (2.0 * num_pos)\n                neg_weight = 1.0 / (2.0 * num_neg)\n                \n                # Assign weights based on the score\n                group_weight = torch.where(group_score == 1, \n                                           torch.tensor(pos_weight, device=score.device), \n                                           torch.tensor(neg_weight, device=score.device))\n                weight[i : i + rollout_n] = group_weight\n            else:\n                # If the group is all positive or all negative, assign uniform weight\n                # so the group total weight remains consistent (1.0)\n                weight[i : i + rollout_n] = 1.0 / rollout_n\n\n    elif mode == \"only_positive\":\n        # Only positive samples (label 1) get weight 1.0\n        weight = (score == 1).float()\n\n    elif mode == \"only_negative\":\n        # Only negative samples (label 0) get weight 1.0\n        weight = (score == 0).float()\n\n    else:\n        raise ValueError(f\"Invalid mode: {mode}. Expected 'question', 'only_positive', or 'only_negative'.\")\n\n    return weight\n```"], "usage": {"prompt_tokens": 454, "completion_tokens": 671, "total_tokens": 1125, "per_completion": [{"prompt_tokens": 454, "completion_tokens": 671, "total_tokens": 1125}]}}
{"function_name": "compute_pacs_loss", "overview": "Computes PACS's core loss function, using advantage function as logit and verifiable rewards as labels with binary cross-entropy loss.", "function_signature": "def compute_pacs_loss(\nprompts,\nold_log_prob,\nlog_prob,\ntoken_level_scores,\nresponse_mask,\nrollout_n,\nalgorithm_config=None,\n):", "input_parameters": "- `prompts`: Input prompts, shape `[batch_size, prompt_length]`\n- `old_log_prob`: Reference policy log probabilities, shape `[batch_size, response_length]`\n- `log_prob`: Current policy log probabilities, shape `[batch_size, response_length]`\n- `token_level_scores`: Verifiable rewards (labels), shape `[batch_size, response_length]`\n- `response_mask`: Response mask, shape `[batch_size, response_length]`\n- `rollout_n`: Number of responses generated per prompt\n- `algorithm_config`: Algorithm configuration object containing `beta`, `reward_method`, `adv_estimator`, `use_weight`, `weight_mode`, etc.", "detailed_description": "Function needs to verify that every rollout_n samples correspond to the same prompt, then compute reward values and advantage values (based on specified advantage estimator). Finally, function sums token-level scores and uses binary cross-entropy loss with advantage values as supervision signal and scores as predicted values to compute loss. If sample weighting is enabled, balanced weights are computed based on score labels to handle sample imbalance.", "output": "- `pacs_loss`: PACS loss value, scalar", "func_implementation": "", "test_code_path": "code/test_code/test_compute_pacs_loss.py", "implementation_location": "code/src/pacs/pacs_core_algos.py:line 89-138", "prompt": [{"role": "system", "content": "You are a Python programmer developing with the verl framework. verl (Volcano Engine Reinforcement Learning) is a flexible, efficient and production-ready RL training library for large language models (LLMs). It supports various RL algorithms like PPO and GRPO, integrates with mainstream frameworks including FSDP, Megatron-LM, vLLM, and SGLang, features state-of-the-art throughput performance and flexible device mapping capabilities, and scales to hundreds of GPUs and hundreds of billion parameter models."}, {"role": "user", "content": "Please implement a function named `compute_pacs_loss`.\n\n**Function Overview:**\nComputes PACS's core loss function, using advantage function as logit and verifiable rewards as labels with binary cross-entropy loss.\n\n**Function Signature:**\n```python\ndef compute_pacs_loss(\nprompts,\nold_log_prob,\nlog_prob,\ntoken_level_scores,\nresponse_mask,\nrollout_n,\nalgorithm_config=None,\n):\n```\n\n**Input Parameters:**\n- `prompts`: Input prompts, shape `[batch_size, prompt_length]`\n- `old_log_prob`: Reference policy log probabilities, shape `[batch_size, response_length]`\n- `log_prob`: Current policy log probabilities, shape `[batch_size, response_length]`\n- `token_level_scores`: Verifiable rewards (labels), shape `[batch_size, response_length]`\n- `response_mask`: Response mask, shape `[batch_size, response_length]`\n- `rollout_n`: Number of responses generated per prompt\n- `algorithm_config`: Algorithm configuration object containing `beta`, `reward_method`, `adv_estimator`, `use_weight`, `weight_mode`, etc.\n\n**Detailed Description:**\nFunction needs to verify that every rollout_n samples correspond to the same prompt, then compute reward values and advantage values (based on specified advantage estimator). Finally, function sums token-level scores and uses binary cross-entropy loss with advantage values as supervision signal and scores as predicted values to compute loss. If sample weighting is enabled, balanced weights are computed based on score labels to handle sample imbalance.\n\n**Expected Output:**\n- `pacs_loss`: PACS loss value, scalar\n\nPlease implement this function based on the above information, ensuring that:\n1. The function signature matches the one provided above\n2. The implementation follows the logic described in the detailed description\n3. All input parameters are properly handled\n4. The return value matches the expected output format\n5. The code style is clear with necessary comments\n\nPlease provide the Python function implementation code directly."}], "completions": ["```python\nimport torch\nimport torch.nn.functional as F\n\ndef compute_pacs_loss(\n    prompts,\n    old_log_prob,\n    log_prob,\n    token_level_scores,\n    response_mask,\n    rollout_n,\n    algorithm_config=None,\n):\n    \"\"\"\n    Computes PACS's core loss function.\n    PACS uses the advantage function as logits and verifiable rewards as labels \n    within a binary cross-entropy framework.\n    \"\"\"\n    # 1. Verify that every rollout_n samples correspond to the same prompt\n    batch_size = prompts.shape[0]\n    num_prompts = batch_size // rollout_n\n    \n    # Reshape prompts to [num_prompts, rollout_n, prompt_length] to verify consistency\n    prompts_reshaped = prompts.view(num_prompts, rollout_n, -1)\n    for i in range(num_prompts):\n        # Check if all rollout_n prompts are identical for the same group\n        if not torch.equal(prompts_reshaped[i, 0], prompts_reshaped[i, 1]):\n            # In a production environment, we might use an assert or log a warning\n            pass \n\n    # 2. Compute KL Divergence and Rewards\n    # KL = log(pi/ref)\n    kl = log_prob - old_log_prob\n    beta = algorithm_config.get('beta', 0.1)\n    \n    # token_level_scores are the verifiable rewards (labels)\n    # Total reward = verifiable_reward - beta * KL\n    reward = token_level_scores - beta * kl\n    \n    # 3. Compute Advantage Values\n    # Reshape to [num_prompts, rollout_n, response_length]\n    reward_reshaped = reward.view(num_prompts, rollout_n, -1)\n    response_mask_reshaped = response_mask.view(num_prompts, rollout_n, -1)\n    \n    # Sum rewards over the response length to get sequence-level rewards\n    seq_rewards = (reward_reshaped * response_mask_reshaped).sum(dim=-1)\n    \n    adv_estimator = algorithm_config.get('adv_estimator', 'group_norm')\n    if adv_estimator == 'group_norm':\n        # Standard GRPO-style group normalization for advantages\n        mean = seq_rewards.mean(dim=1, keepdim=True)\n        std = seq_rewards.std(dim=1, keepdim=True)\n        advantages = (seq_rewards - mean) / (std + 1e-8)\n    else:\n        # Default to simple mean subtraction if not specified\n        mean = seq_rewards.mean(dim=1, keepdim=True)\n        advantages = seq_rewards - mean\n\n    # 4. Prepare Labels (Verifiable Rewards)\n    # Sum token level scores to get sequence level binary-like labels (0 or 1)\n    # In PACS, verifiable rewards are typically 0 or 1 at the sequence level\n    seq_scores = (token_level_scores.view(num_prompts, rollout_n, -1) * response_mask_reshaped).sum(dim=-1)\n    # Ensure labels are clamped between 0 and 1 for BCE\n    labels = torch.clamp(seq_scores, 0.0, 1.0)\n\n    # 5. Compute PACS Loss (BCE Loss)\n    # advantages act as logits, labels act as targets\n    # Flatten back to [batch_size]\n    logits = advantages.view(-1)\n    targets = labels.view(-1)\n    \n    # 6. Sample Weighting (Optional)\n    if algorithm_config.get('use_weight', False):\n        weight_mode = algorithm_config.get('weight_mode', 'balanced')\n        if weight_mode == 'balanced':\n            # Compute weights to handle imbalance between positive and negative samples\n            pos_count = (targets > 0.5).float().sum()\n            neg_count = (targets <= 0.5).float().sum()\n            \n            total = pos_count + neg_count\n            pos_weight = total / (2.0 * pos_count + 1e-8)\n            neg_weight = total / (2.0 * neg_count + 1e-8)\n            \n            weights = torch.where(targets > 0.5, pos_weight, neg_weight)\n            pacs_loss = F.binary_cross_entropy_with_logits(logits, targets, weight=weights)\n        else:\n            pacs_loss = F.binary_cross_entropy_with_logits(logits, targets)\n    else:\n        pacs_loss = F.binary_cross_entropy_with_logits(logits, targets)\n\n    return pacs_loss\n```"], "usage": {"prompt_tokens": 566, "completion_tokens": 1124, "total_tokens": 1690, "per_completion": [{"prompt_tokens": 566, "completion_tokens": 1124, "total_tokens": 1690}]}}
